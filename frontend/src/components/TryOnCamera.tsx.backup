/**
 * TryOnCamera - Main AR component for virtual jewelry try-on
 * Combines camera feed, face tracking, and jewelry      // Get actual ear positions from MediaPipe Pose
      // Note: MediaPipe ear landmarks point to the ear canal/center
      // We need to offset them down and outward for earring position
      const earDownOffset = 0.08;  // Move down from ear landmark (as percentage of canvas height)
      const earOutOffset = 0.02;   // Move slightly outward
      
      const leftEarX = (earLandmarks.left.x - earOutOffset) * canvas.width;
      const leftEarY = (earLandmarks.left.y + earDownOffset) * canvas.height;
      const rightEarX = (earLandmarks.right.x + earOutOffset) * canvas.width;
      const rightEarY = (earLandmarks.right.y + earDownOffset) * canvas.height;

      console.log(`üëÇ Raw Ear Landmarks - Left: (${(earLandmarks.left.x * canvas.width).toFixed(0)}, ${(earLandmarks.left.y * canvas.height).toFixed(0)}), Right: (${(earLandmarks.right.x * canvas.width).toFixed(0)}, ${(earLandmarks.right.y * canvas.height).toFixed(0)})`);
      console.log(`üíç Earring positions - Left: (${leftEarX.toFixed(0)}, ${leftEarY.toFixed(0)}), Right: (${rightEarX.toFixed(0)}, ${rightEarY.toFixed(0)})`);

      // Calculate size
      const size = jewelry.ar_config.size || 25;
      const color = jewelry.ar_config.color || '#FFD700'; */

import { useRef, useEffect, useState } from 'react';
import { useImprovedEarTracking } from '../hooks/useImprovedEarTracking';

interface JewelryItem {
  item_id: string;
  name: string;
  type: string;
  ar_config: {
    landmarks: number[];
    size: number;
    color?: string;
    material?: { type: string; opacity?: number };
    physics?: { enabled: boolean; damping?: number; stiffness?: number };
    auto_scale?: boolean;
  };
  image_url?: string;
}

interface TryOnCameraProps {
  jewelry: JewelryItem;
}

export const TryOnCamera: React.FC<TryOnCameraProps> = ({ jewelry }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const { initializeFaceLandmarker, processFrame } = useImprovedEarTracking();
  const [renderCount, setRenderCount] = useState(0);
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [earPositions, setEarPositions] = useState<{
    leftEar: { x: number; y: number; scale: number; depth: number; rotation: number } | null;
    rightEar: { x: number; y: number; scale: number; depth: number; rotation: number } | null;
  }>({
    leftEar: null,
    rightEar: null
  });

  // Log jewelry data on mount
  useEffect(() => {
    console.log('üé® Jewelry loaded:', jewelry);
    console.log('üéØ AR Config:', jewelry.ar_config);
  }, [jewelry]);

  /**
   * Initialize camera on component mount
   */
  useEffect(() => {
    const startCamera = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          console.log('üìπ Camera started successfully');
        }
      } catch (err) {
        console.error('‚ùå Camera access denied:', err);
      }
    };

    startCamera();

    return () => {
      const stream = videoRef.current?.srcObject as MediaStream;
      stream?.getTracks().forEach(track => track.stop());
    };
  }, []);

  /**
   * Initialize Face Landmarker
   */
  useEffect(() => {
    const init = async () => {
      try {
        await initializeFaceLandmarker();
        setIsReady(true);
        console.log('‚úÖ Face landmarker initialized');
      } catch (err) {
        setError('Failed to initialize face tracking');
        console.error('‚ùå Initialization error:', err);
      }
    };
    init();
  }, [initializeFaceLandmarker]);

  /**
   * Main rendering loop - draws jewelry on canvas using actual ear landmarks
   */
  useEffect(() => {
    if (!canvasRef.current || !videoRef.current) {
      console.log('‚ö†Ô∏è Canvas or video ref not ready');
      return;
    }

    const canvas = canvasRef.current;
    const video = videoRef.current;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      console.error('‚ùå Could not get canvas context');
      return;
    }

    // Wait for video to be ready
    if (!video.videoWidth || !video.videoHeight) {
      console.log('‚è≥ Video not ready yet');
      return;
    }

    const animate = () => {
      // Match canvas size to video dimensions
      if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        console.log(`üìê Canvas resized to match video: ${canvas.width}x${canvas.height}`);
      }

      // Clear previous frame
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!earLandmarks.left || !earLandmarks.right) {
        // Draw waiting indicator
        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
        ctx.fillRect(10, 10, 200, 40);
        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText('Detecting ears...', 15, 35);
        requestAnimationFrame(animate);
        return;
      }

      setRenderCount(prev => prev + 1);

      // Get actual ear positions from MediaPipe Pose
      const leftEarX = earLandmarks.left.x * canvas.width;
      const leftEarY = earLandmarks.left.y * canvas.height;
      const rightEarX = earLandmarks.right.x * canvas.width;
      const rightEarY = earLandmarks.right.y * canvas.height;

      console.log(`ÔøΩ Ears - Left: (${leftEarX.toFixed(0)}, ${leftEarY.toFixed(0)}), Right: (${rightEarX.toFixed(0)}, ${rightEarY.toFixed(0)})`);

      // Calculate size
      const size = jewelry.ar_config.size || 25;
      const color = jewelry.ar_config.color || '#FFD700';

      // Draw left earring
      ctx.fillStyle = color;
      ctx.strokeStyle = '#DAA520'; // Darker gold outline
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(leftEarX, leftEarY, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Add highlight to left earring
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(leftEarX - size * 0.3, leftEarY - size * 0.3, size * 0.3, 0, Math.PI * 2);
      ctx.fill();

      // Draw right earring
      ctx.fillStyle = color;
      ctx.strokeStyle = '#DAA520';
      ctx.beginPath();
      ctx.arc(rightEarX, rightEarY, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Add highlight to right earring
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(rightEarX - size * 0.3, rightEarY - size * 0.3, size * 0.3, 0, Math.PI * 2);
      ctx.fill();

      requestAnimationFrame(animate);
    };

    const animationId = requestAnimationFrame(animate);

    return () => {
      cancelAnimationFrame(animationId);
    };
  }, [earLandmarks, jewelry]);

  return (
    <div className="relative w-full h-screen bg-black flex items-center justify-center overflow-hidden">
      {/* Camera video feed */}
      <video
        ref={videoRef}
        autoPlay
        playsInline
        muted
        className="w-full h-full object-contain"
        style={{ 
          transform: 'scaleX(-1)',
          position: 'absolute',
          top: 0,
          left: 0
        }}
        onLoadedMetadata={() => {
          console.log('üìπ Video dimensions:', videoRef.current?.videoWidth, 'x', videoRef.current?.videoHeight);
        }}
      />
      
      {/* AR rendering canvas */}
      <canvas
        ref={canvasRef}
        className="pointer-events-none"
        style={{ 
          transform: 'scaleX(-1)',
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          objectFit: 'contain'
        }}
      />
      
      {/* Debug panel */}
      <div className="absolute top-4 left-4 bg-black/80 backdrop-blur-sm rounded-lg p-4 shadow-lg text-white z-30">
        <h3 className="font-bold mb-2">üîç Debug Info</h3>
        <div className="text-xs space-y-1">
          <p>Pose Ready: {isReady ? '‚úÖ' : '‚ùå'}</p>
          <p>Ears Detected: {earLandmarks.left && earLandmarks.right ? '‚úÖ' : '‚ùå'}</p>
          <p>Renders: {renderCount}</p>
          <p>Video Size: {videoRef.current?.videoWidth || 0}x{videoRef.current?.videoHeight || 0}</p>
          <p>Canvas Size: {canvasRef.current?.width || 0}x{canvasRef.current?.height || 0}</p>
          <p>Jewelry: {jewelry.name}</p>
          <p>Type: {jewelry.type}</p>
        </div>
      </div>
      
      {/* Ear detection indicator */}
      <div className="absolute top-4 right-4 flex items-center gap-2 z-30">
        <div className={`w-4 h-4 rounded-full ${earLandmarks.left && earLandmarks.right ? 'bg-green-500 animate-pulse' : 'bg-red-500'}`}></div>
        <span className="text-white text-sm bg-black/50 px-3 py-1 rounded">
          {earLandmarks.left && earLandmarks.right ? '‚úÖ Ears Detected' : '‚è≥ Detecting...'}
        </span>
      </div>
      
      {/* Loading indicator */}
      {!isReady && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/70 z-20">
          <div className="text-center">
            <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-white mx-auto mb-4"></div>
            <p className="text-white text-lg">Loading Pose Detection...</p>
            <p className="text-white text-sm mt-2">Initializing ear tracking...</p>
          </div>
        </div>
      )}
      
      {/* Error display */}
      {error && (
        <div className="absolute top-20 left-4 right-4 bg-red-500 text-white p-4 rounded-lg z-30">
          <p className="font-semibold">‚ùå Error: {error}</p>
        </div>
      )}
      
      {/* Jewelry info */}
      <div className="absolute bottom-4 left-4 bg-white/90 backdrop-blur-sm rounded-lg p-4 shadow-lg z-30">
        <h3 className="font-bold text-lg text-gray-900">{jewelry.name}</h3>
        <p className="text-sm text-gray-600">{jewelry.type}</p>
      </div>
    </div>
  );
};
